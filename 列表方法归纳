append(x)追加到链尾
clear()清空列表元素
copy()列表的浅拷贝
extend(L)追加一个列表，等价于+=
insert(i,x)在位置i插入x，其余元素向后推，如果i大于列表长度，就在最后添加，如果i小于0，就在最开始添加
remove(x)删除第一个值为x的元素，如果不存在会抛出异常
reverse()反转序列
pop([i])返回并删除位置为i的元素，i默认为最后一个元素
index(x)返回x在列表中第一次出现的位置，不存在则抛出异常
count(x)返回x出现的次数
sort()排序
len(List)返回List的长度
del list[i]删除列表list中指定的第i+1个变量
切片
切片指的是抽取序列的一部分，其形式为：list[start:end:step]。其抽取的规则是：一般默认的步长为1，但也可自定义。

python中对list去重的多种方法
今天遇到一个问题，在同事随意的提示下，用了 itertools.groupby 这个函数。不过这个东西最终还是没用上。

问题就是对一个list中的id进行去重，去重之后要保证顺序不变。

直观方法
最简单的思路就是：
ids = [1,2,3,3,4,2,3,4,5,6,1]
news_ids = []
for id in ids:
    if id not in news_ids:
        news_ids.append(id)
print news_ids
这样也可行，但是看起来不够爽。

用set
另外一个解决方案就是用set：
ids = [1,4,3,3,4,2,3,4,5,6,1]
ids = list(set(ids))
这样的结果是没有保持原来的顺序

按照索引再次排序
最后通过这种方式解决：
ids = [1,4,3,3,4,2,3,4,5,6,1]
news_ids = list(set(ids))
news_ids.sort(ids.index)

使用itertools.grouby
文章一开始就提到itertools.grouby, 如果不考虑列表顺序的话可用这个：
ids = [1,4,3,3,4,2,3,4,5,6,1]
ids.sort()
it = itertools.groupby(ids)
for k, g in it:
    print k
关于itertools.groupby的原理可以看这里：http://docs.python.org/2/library/itertools.html#itertools.groupby

用reduce
In [5]: ids = [1,4,3,3,4,2,3,4,5,6,1]
In [6]: func = lambda x,y:x if y in x else x + [y]
In [7]: reduce(func, [[], ] + ids)
Out[7]: [1, 4, 3, 2, 5, 6]
上面是我在ipython中运行的代码，其中的 lambda x,y:x if y in x else x + [y] 等价于 lambda x,y: y in x and x or x+[y] 
思路其实就是先把ids变为[[], 1,4,3,......] ,然后在利用reduce的特性。









